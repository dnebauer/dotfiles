#!/usr/bin/env bash

# File: i3-apply-layouts
# Author: David Nebauer (david at nebauer dot org)
# Purpose: append all layouts and remap visible windows
# Created: 2022-05-11
# Credit: https://www.freelists.org/post/i3-discuss/\
#         Windows-do-not-swallow-after-restoring-layout,4


# ERROR HANDLING

# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Exit on error inside any functions or subshells.
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch error in case mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
set -o pipefail
# Turn on traces, useful while debugging but commented out by default
# set -o xtrace

# VARIABLES

self="$(basename $0)"
session_dir="$HOME/.config/i3/sessions"
required_tools=(
    getopt
    i3-msg
    xdotool
)


# PROCEDURES

# Show usage
#   params: nil
#   prints: nil
#   return: nil
displayUsage () {
cat << _USAGE
${self}: append all i3 layouts and remap visible windows

The i3 window manager is able to apply saved layouts with
the 'append_layout' command. This script assumes all files
in the "~/.config/i3/sessions" directory with a ".json"
extension are layout files. It is further assumed each file
is named "workspace-<X>.json" where <X> is the number or
name of the workspace the file's layout applies to. The
script appends/applies each file to the appropriate
workspace with the i3 command:
    workspace <X>; append_layout <layout_file_path>

The script then remaps all visible windows so that any which
match "swallows" criteria in the layouts are assigned to the
specified containers.

Usage: ${self} [-v] [-d]
       ${self} -h

Options: -v = print lines as they are read
              (equivalent to 'set -o verbose')
         -d = print lines with commands expanded
              (equivalent to 'set -o xtrace')
_USAGE
}
# Process command line options
#   params: all command line parameters
#   prints: feedback
#   return: nil
#   note:   after execution variable ARGS contains
#           remaining command line args (after options removed)
processOptions () {
    # read the command line options
    local OPTIONS="$(                     \
        getopt                            \
            --options hvd                 \
            --long    help,verbose,debug  \
            --name    "${BASH_SOURCE[0]}" \
            -- "${@}"                     \
    )"
    [[ ${?} -eq 0 ]] || {
        echo 'Invalid command line options' 1>&2
        exit 1
    }
    eval set -- "${OPTIONS}"
    while true ; do
        case "${1}" in
        -h | --help    ) displayUsage   ; exit 0  ;;
        -v | --verbose ) set -o verbose ; shift 1 ;;
        -d | --debug   ) set -o xtrace  ; shift 1 ;;
        --             ) shift ; break ;;
        *              ) break ;;
        esac
    done
    ARGS="${@}"  # remaining arguments
}
# Join items
#   params: 1  - delimiter
#           2+ - items to be joined
#   prints: string containing joined items
#   return: nil
function joinBy () {
    local d=$1
    shift
    local f=$1
    shift
    printf %s "$f" "${@/#/$d}"
}
# Append layout files
#   params: nil
#   prints: nil
#   return: nil
appendLayouts () {
    local layout_fp=
    for layout_fp in $session_dir/workspace-*.json ; do
        # if no match returns single value ".../workpace-*.json"
        # - this value with literal asterisk matches no real file
        [[ -f "${layout_fp}" ]] || continue
        local base= workspace=
        base="$(basename "$layout_fp" ".json")"
        workspace="${base/workspace-/}"
        i3-msg "workspace $workspace; append_layout $layout_fp"
    done
    i3-msg 'workspace 1'
}
# Remap visible windows
#   params: nil
#   prints: nil
#   return: nil
remapWindows () {

    # get list of windows
    local ids= id=
    ids=$(xdotool search --onlyvisible '')
    IFS='
    '
    ids=( $ids )

    # remap windows to trigger 'swallow'
    for id in "${ids[@]}" ; do
        xdotool windowunmap $id
        xdotool windowmap $id
    done
}


# MAIN

# Check for required tools
missing=()
for tool in "${required_tools[@]}" ; do
    command -v "${tool}" &>/dev/null || missing+=("${tool}")
done
[[ ${#missing[@]} -eq 0 ]] \
    || dnFailScript "Can't run without: $(joinBy ', ' "${missing[@]}")"
unset missing tools required_tools

# Process command line options
# - results in $ARGS holding remaining non-option command line arguments
processOptions "${@}"

# Append layout files
appendLayouts

# Remap visible windows
remapWindows

# vim:foldmethod=marker:

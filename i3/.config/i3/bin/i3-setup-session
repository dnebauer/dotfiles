#!/usr/bin/env bash

# File: i3-setup-session
# Author: David Nebauer (david at nebauer dot org)
# Purpose: set up initial i3 session
# Created: 2022-05-25


# ERROR HANDLING    {{{1

# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Exit on error inside any functions or subshells.
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch error in case mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
set -o pipefail
# Turn on traces, useful while debugging but commented out by default
# set -o xtrace

# VARIABLES    {{{1

self="$(basename "$0")"
dlg_title='i3 session setup'
required_tools=(
    astroid-launcher   nvim-qt
    date               qutebrowser
    getopt             sleep
    i3-msg             tiddlywiki
    konsole            xdotool
)
# trial and error showed that any app post-launch delay < 1 second caused
# problems for qutebrowser windows resetting their titles, independently of the
# delay before the titling itself (even if there is no reasonable explanation
# for that!)
delay_post_launch=1
delay_app_loading=30
logging='false'             # whether to log
logfile="$HOME/$self.log"   # log file
logged='false'              # whether anything logged yet
# }}}1

# PROCEDURES

# Show usage    {{{1
#   params: nil
#   prints: nil
#   return: nil
displayUsage () {
cat << _USAGE
$self: app launcher called during i3 startup

This script is called by the i3 config file during startup
to launch applications. The main purpose for using this
script rather than internal i3 commands is to control the
window role assigned to some apps. This enables them to be
"swallowed" by preset layouts.

It is essential that this script is consistent with any
applied layouts and with the i3 config file. This includes,
but is not limited to, consistency with workspace names.

Usage: $self [-v] [-d] [-l] [-f filepath]
       $self -h

Options: -v    = print input lines after command expansion
                 (equivalent to 'set -o verbose')
         -d    = print input lines as they are read
                 (equivalent to 'set -o xtrace')
         -l    = write debug output to log
         -f fp = log file (default=~/$self.log)
_USAGE
}
# Log messages    {{{1
#   params: 1+ - msg
#   prints: nil
#   return: nil
logMsg () {
    [[ "$logging" = 'true' ]] || return
    while [[ $# -gt 0 ]] ; do
        local msg="${1}"
        if [[ "$logged" = 'true' ]] ; then
            echo "$msg" >> "$logfile"
        else
            echo "$msg" > "$logfile"
            logged='true'
        fi
        shift
    done
}
# Process command line options    {{{1
#   params: all command line parameters
#   prints: feedback
#   return: nil
#   note:   after execution variable ARGS contains
#           remaining command line args (after options removed)
processOptions () {
    # read the command line options
    local OPTIONS="$(                                \
        getopt                                       \
            --options lf:hvd                         \
            --long    log,logfile,help,verbose,debug \
            --name    "${BASH_SOURCE[0]}"            \
            -- "${@}"                                \
    )"
    [[ ${?} -eq 0 ]] || {
        echo 'Invalid command line options' 1>&2
        exit 1
    }
    eval set -- "${OPTIONS}"
    while true ; do
        case "${1}" in
        -l | --log     ) logging='true'  ; shift 1 ;;
        -f | --logfile ) logfile="${2}"  ; shift 2 ;;
        -h | --help    ) displayUsage    ; exit 0  ;;
        -v | --verbose ) set -o verbose  ; shift 1 ;;
        -d | --debug   ) set -o xtrace   ; shift 1 ;;
        --             ) shift ; break ;;
        *              ) break ;;
        esac
    done
    ARGS="${@}"  # remaining arguments
}
# Join items    {{{1
#   params: 1  - delimiter
#           2+ - items to be joined
#   prints: string containing joined items
#   return: nil
function joinBy () {
    local d=$1
    shift
    local f=$1
    shift
    printf %s "$f" "${@/#/$d}"
}
# Send qutebrowser command    {{{1
#   params: 1 - window id
#           2 - command
#   prints: nil
#   return: nil
function qbCommand () {
    # extract parameters
    local id cmd
    id=$1
    cmd="$2"

    # send command to nominated qutebrowser instance
    xdotool windowactivate --sync $id
    xdotool key  --window $id --clearmodifiers colon
    xdotool type --window $id --clearmodifiers "$cmd"
    xdotool key  --window $id --clearmodifiers Return
}    # }}}1

# MAIN

# Check for required tools    {{{1
#logMsg "$(date '+%A %Y-%m-%d, %H:%M:%S')" \
#       'Start session setup' \
#       '-------------------' \
#       'Delay for 30 seconds'
#sleep 30
#logMsg 'Checking for missing tools'
missing=()
for tool in "${required_tools[@]}" ; do
    command -v "${tool}" &>/dev/null || missing+=("${tool}")
done
if [[ ${#missing[@]} -ne 0 ]] ; then
    #logMsg "Missing: $(joinBy ', ' "${missing[@]}")"
    echo "Can't run without: $(joinBy ', ' "${missing[@]}")" >/dev/stderr
    exit 1
fi
#logMsg 'No missing tools'
unset missing tools required_tools

# Process command line options    {{{1
# - results in $ARGS holding remaining non-option command line arguments
#logMsg 'Processing command line options'
processOptions "${@}"
#logMsg 'Command line options processed'

# Assign workspaces to monitors    {{{1
# - this must be done in the i3 setup file
# - there appears to be no way to construct the workspace command in shell
#   script using i3-msg without i3 interpreting the workspace name as being
#   everything following the token 'workspace'
# - for posterity, what follows is the final attempt at setting workspace 1:
##i3-msg workspace '1:term' output $primary_monitor
# - this was an earlier attempt (expand to include other workspaces and the
#   secondary monitor:
##primary_workspaces=(1:term)
##for workspace in "${primary_workspaces[@]}" ; do
##    i3-msg workspace "$workspace" output $primary_monitor
##done

# Apply layouts to workspaces    {{{1
#logMsg 'Appending layout to workspace 1'
i3-msg 'workspace 1:term; append_layout ~/.config/i3/sessions/workspace_1.json'
#logMsg 'Appending layout to workspace 2'
i3-msg 'workspace 2:mail; append_layout ~/.config/i3/sessions/workspace_2.json'
#logMsg 'Appending layout to workspace 3'
i3-msg 'workspace 3:chrome; append_layout ~/.config/i3/sessions/workspace_3.json'
#logMsg 'Appending layout to workspace 4'
i3-msg 'workspace 4:qute; append_layout ~/.config/i3/sessions/workspace_4.json'
#logMsg 'Appending layout to workspace 5'
i3-msg 'workspace 5:wiki; append_layout ~/.config/i3/sessions/workspace_5.json'
#logMsg 'Finished appending layouts'
# layouts define the following marks:
# - workspace 1: t=term, v=vim
# - workspace 2: m=astroid/mail
# - workspace 3: c=chrome
# - workspace 4: g=games
# - workspace 5: w=wiki

# Launch apps    {{{1

# nvim-qt
#logMsg 'Launching nvim-qt'
nvim-qt &
sleep $delay_post_launch
#logMsg 'Nvim-qt launched'

# astroid
#logMsg 'Launching astroid'
astroid-launcher &
sleep $delay_post_launch
#logMsg 'Astroid launched'

# qutebrowser (mail: gmail, primus)
#logMsg 'Launching qutebrowser/mail'
qutebrowser --set window.title_format "qutebrowser/mail" --restore mail &
sleep $delay_post_launch
#logMsg 'Qutebrowser/mail launched'

# google-chrome
#logMsg 'Launching google chrome'
google-chrome &
sleep $delay_post_launch
#logMsg 'Google chrome launched'

# qutebrowser (porn)
#logMsg 'Launching qutebrowser/porn'
qutebrowser --set window.title_format "qutebrowser/porn" --restore porn &
sleep $delay_post_launch
#logMsg 'Qutebrowser/porn launched'

# qutebrowser (music)
#logMsg 'Launching qutebrowser/music'
qutebrowser --set window.title_format "qutebrowser/music" --restore music &
sleep $delay_post_launch
#logMsg 'Qutebrowser/music launched'

# qutebrowser (vim)
#logMsg 'Launching qutebrowser/vim'
qutebrowser --set window.title_format "qutebrowser/vim" --restore vim &
sleep $delay_post_launch
#logMsg 'Qutebrowser/vim launched'

# qutebrowser (games)
#logMsg 'Launching qutebrowser/games'
qutebrowser --set window.title_format "qutebrowser/games" --restore games &
sleep $delay_post_launch
#logMsg 'Qutebrowser/games launched'

# tiddlywiki
#logMsg 'Launching tiddlywiki'
plugin_path="/usr/local/share/tiddlywiki/plugins"
alacritty \
    -t launcher_tiddlywiki \
    -o env.TIDDLYWIKI_PLUGIN_PATH=$plugin_path \
    -e tiddlywiki $HOME/data/misc/auxiliary-memory --listen port=10744 &
sleep $delay_post_launch
#logMsg 'Tiddlywiki launched'

# qutebrowser (wiki)
#logMsg 'Launching qutebrowser/wiki'
qutebrowser --set window.title_format "qutebrowser/wiki" --restore wiki &
sleep $delay_post_launch
#logMsg 'Qutebrowser/wiki launched'

# alacritty/tmux
#logMsg 'Launching alacritty running tmux'
alacritty \
    --class 'AlacrittyTmux,AlacrittyTmux' \
    --title 'AlacrittyTmux' \
    --command tmux &
sleep $delay_post_launch
#logMsg 'Alacritty running tmux launched'

# Ensure dunst is available    {{{1
check_count=1
#logMsg 'Checking that dunst is available'
while ! systemctl --user --quiet is-active dunst ; do
    #logMsg "Dunst check $check_count failed"
    ((check_count++))
    sleep 1
done
#logMsg 'Dunst is available'
# Post-launch tasks    {{{1
# - some tasks cannot be performed until the relevant app has finished loading
# - trial and error showed that 30 seconds is sufficient for the computer and
#   internet speeds in use at the time this script was written
#logMsg "Delaying $delay_app_loading seconds to load apps"
while [[ $delay_app_loading -gt 0 ]] ; do
    dunstify \
        --replace=101 \
        "$dlg_title" \
        "Giving apps $delay_app_loading seconds to load"
    let "delay_app_loading--"
    sleep 1
done
dunstify --close=101
#logMsg 'App loading delay complete'

# Reload wiki qutebrowser tab    {{{2
# - if it loaded before the tiddlywiki server finished loading then it
#   displays a page-not-found error
# - must do this task before qutebrowser window titles are reset because
#   window title ('name') is used to identify specific qutebrowser window
#logMsg 'Reloading wiki qutebrowser tab'
wiki_ids=($(xdotool search --name "qutebrowser/wiki"))
if [[ ${#wiki_ids[@]} -eq 0 ]] ; then
    dunstify --urgency=critical "$dlg_title" \
        'Cannot locate qutebrowser showing tiddlywiki'
elif [[ ${#wiki_ids[@]} -gt 1 ]] ; then
    dunstify --urgency=critical "$dlg_title" \
        "Whoah! Detected ${#wiki_ids[@]} qutebrowsers showing tiddlywiki"
else
    wiki_id="${wiki_ids[0]}"
    qbCommand "$wiki_id" "tab-focus 1"
    sleep $delay_app_loading
    qbCommand "$wiki_id" "reload"
    sleep 3
fi
#logMsg 'Wiki qutebrowser tab reloaded'

# Change settings in all qutebrowser instances    {{{2
# - it appears all qutebrowser instances must finish loading in order for the
#   'set' command to execute correctly
# - it seems an actively loading qutebrowser window interferes with xdotool
#   typing its keys, and it is unpredictable which keys are received by the
#   window and which are 'lost'
# - task 1: reset title of qutebrowser windows to display active tab title
# - task 2: reset download directory
# -         * wrapper script causes default download directory to be
#             /run/user/1000/qutebrowser/SESSION/download/
#           * reset to ~/Downloads/
#logMsg 'Resetting qutebrowser window titles'
title='{perc}{current_title}{title_sep}qutebrowser'
cmd_reset_title="set window.title_format $title"
cmd_reset_download_dir="set downloads.location.directory ~/Downloads"
window_ids=($(xdotool search --class qutebrowser))
if [[ ${#window_ids[@]} -eq 0 ]] ; then
    dunstify --urgency=critical "$dlg_title" \
        'Cannot locate any qutebrowsers to retitle'
else
    for window_id in "${window_ids[@]}" ; do
        qbCommand "$window_id" "$cmd_reset_title"
        qbCommand "$window_id" "$cmd_reset_download_dir"
    done
fi
#logMsg 'Qutebrowser window titles reset completed'

# Focus astroid in mail workspace    {{{2
#logMsg 'Focussing astroid'
i3-msg [class="Astroid" instance="astroid"] focus
#logMsg 'Astroid focussed'

# Focus terminal in workspace 1    {{{2
#logMsg 'Focussing main terminal'
i3-msg [class="AlacrittyTmux" instance="AlacrittyTmux"] focus
#logMsg 'Main terminal focussed'

# Launch status bar    {{{1
#logMsg 'Launching polybar'
~/.config/polybar/launch
#logMsg 'Polybar launched'

# Notify completion    {{{1
#logMsg '----------------------' \
#       'Session setup complete' \
#       "$(date '+%A %Y-%m-%d, %H:%M:%S')"
dunstify "$dlg_title" 'Session setup complete'
# }}}1

# vim:foldmethod=marker:

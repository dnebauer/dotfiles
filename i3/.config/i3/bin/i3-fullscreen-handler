#!/usr/bin/perl

use Moo;                 # {{{1
use strictures 2;
use 5.006;
use 5.022_001;
use version; our $VERSION = qv('0.1');
use namespace::clean;    # }}}1

{

    package Dn::Internal;

    # resources    # {{{1
    use Moo;
    use strictures 2;
    use namespace::clean -except => [ '_options_data', '_options_config' ];
    use sigtrap qw(handler _handle_sigs normal-signals
        stack-trace error-signals);
    use AnyEvent::I3;
    use Carp qw(croak);
    use Const::Fast;
    use English qw(-no_match_vars);
    use File::Which;
    use Function::Parameters;
    use MooX::HandlesVia;
    use MooX::Options protect_argv => 0;
    use Sys::Syslog;
    use Types::Standard;
    use experimental 'switch';

    const my $TRUE           => 1;
    const my $FALSE          => 0;
    const my $CHECK_INTERVAL => 15;
    const my $NOTIFY_TIME    => 5;
    Sys::Syslog::openlog( 'i3 fullscreen handler', 'nofatal', 'user' );

    # main()    {{{1
    #
    # does:   main method
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method main () {

        $self->_check_dependencies;

        my $previously_fullscreen;
        my $first_loop = $TRUE;

        # infinite loop
        while ($TRUE) {

            # get current fullscreen status
            my $tree = i3->get_tree->recv;
            my $currently_fullscreen
                = $self->_have_fullscreen_container($tree);

            # handle first time through loop
            if ($first_loop) {
                $previously_fullscreen = $currently_fullscreen;
                $first_loop            = $FALSE;
            }

            # handle change in fullscreen status
            if ( $currently_fullscreen and not $previously_fullscreen ) {
                $self->_enter_fullscreen;
            }
            if ( $previously_fullscreen and not $currently_fullscreen ) {
                $self->_leave_fullscreen;
            }

            # prepare for next pass through loop
            $previously_fullscreen = $currently_fullscreen;
            sleep $CHECK_INTERVAL;
        }

        return;
    }

    # _have_fullscreen_container($hashref)    {{{1
    #
    # does:   analyses hash iteratively
    # params: 1 - hash_ref
    # prints: nil
    # return: boolean, whether fullscreen container found
    method _have_fullscreen_container ($hash_ref) {

        # test whether this is a fullscreen container
        my %hash = %{$hash_ref};
        if ( ( exists $hash{'type'} ) and ( $hash{'type'} eq 'con' ) ) {
            if ( exists $hash{'fullscreen_mode'} ) {
                return $TRUE if $hash{'fullscreen_mode'} == $TRUE;
            }
        }

        # not a fullscreen container, so iterate
        # - okay to use 'each' because loop does not modify hash
        ## no critic (Community::Each, Freenode::Each)
        while ( my ( $key, $value ) = each %hash ) {
            ## use critic
            if ( 'HASH' eq ref $value ) {
                return $TRUE if $self->_have_fullscreen_container($value);
            }
            if ( 'ARRAY' eq ref $value ) {
                my @array = @{$value};
                for my $element (@array) {
                    if ( 'HASH' eq ref $element ) {
                        return $TRUE
                            if $self->_have_fullscreen_container($element);
                    }
                }
            }
        }

        # reached here if no fullscreen container found, so return false
        return;
    }

    # _enter_fullscreen()    {{{1
    #
    # does:   handle container entering fullscreen
    # params: nil
    # prints: nil
    # return: n/a, dies on failure
    method _enter_fullscreen () {

        # log activity
        syslog( 'info', 'detected fullscreen container' );
        syslog( 'info', 'disabling notifications and screensaver' );

        # notify user
        system 'dunstify', '--replace=337', 'Detected fullscreen container',
            'Disabling screensaver and notifications';
        sleep $NOTIFY_TIME;

        # turn off screensaver
        system 'xset', 's', 'off';
        system 'xset', '-dpms';

        # disable notifications
        # - (un)pausing dunst also (un)pauses libnotify
        system 'dunstctl', 'set-paused', 'true';

        return;
    }

    # _leave_fullscreen()    {{{1
    #
    # does:   handle container leaving fullscreen
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method _leave_fullscreen () {

        # log activity
        syslog( 'info', 'container no longer fullscreen' );
        syslog( 'info', 'enabling notifications and screensaver' );

        # turn on screensaver
        system 'xset', 's', 'on';
        system 'xset', '+dpms';

        # enable notifications
        # - (un)pausing dunst also (un)pauses libnotify
        system 'dunstctl', 'set-paused', 'false';

        # notify user
        system 'dunstify', '--replace=337', 'No more fullscreen containers',
            'Re-enabled screensaver and notifications';

        return;
    }

    # _check_dependencies()    {{{1
    #
    # does:   checks that required executables are available
    # params: nil
    # prints: error message if dependencies are missing
    # return: n/a, dies with err message if missing dependencies
    method _check_dependencies () {

        # check for required tools
        my @required = qw(dunstctl xset);
        my @missing;
        for my $tool (@required) {
            if ( not File::Which::which $tool) {
                push @missing, $tool;
            }
        }

        # die if missing any required tool
        if (@missing) {
            my $frag = join ', ', @missing;
            die "Fatal error: missing $frag\n";
        }

        return;
    }

    # _handle_sigs()    {{{1
    #
    # does:   handle external termination of script
    # params: nil
    # prints: nil
    # return: n/a
    method _handle_sigs () {

        # close logger gracefully
        Sys::Syslog::closelog;

        # notify user
        die "Caught a signal $OS_ERROR\n";
        ## no critic (CodeLayout::RequireFinalSemicolon)
    }
    ## use critic
    # }}}1
}

my $p = Dn::Internal->new_with_options->main;

1;

# POD    {{{1
__END__

=encoding utf8

=head1 NAME

i3-fullscreen-handler - does stuff ...

=head1 USAGE

B<i3-fullscreen-handler>

B<i3-fullscreen-handler -h>

=head1 REQUIRED ARGUMENTS

Nil.

=head1 REQUIRED OPTIONS

Nil.

=head1 OPTIONS

=over

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

A simple daemon for use with the L<i3 window manager|https://i3wm.org>. It
periodically checks for fullscreen containers.

If the script detects a change in status from no fullscreen containers to a
fullscreen container being present, it takes the following actions:

=over

=item

the screensaver is deactivated

=item

screen notifications from L<dunst|https://dunst-project.org/> and
L<libnotify|http://www.galago-project.org/specs/notification/> daemons are
disabled.

=back

If the script detects the reverse transition, from a fullscreen container being
present to no fullscreen containers being present, it takes the following
actions:

=over

=item

the screensaver is activated

=item

screen notifications from dunst and libnotify are re-enabled.

=back

When a change in fullscreen container status is detected the user is notified
by a screen notification and a message is written to the system logger.

=head1 DIAGNOSTICS

There are no diagnostic messages expected to be issued by this script.

=head1 DEPENDENCIES

=head2 Perl modules

AnyEvent::I3, Carp, Const::Fast, English, experimental, File::Which,
Function::Parameters, Moo, MooX::HandlesVia, MooX::Options, namespace::clean,
strictures, Sys::Syslog, Types::Standard.

=head2 Executables

dunstcmd, dunstify, xset.

=head1 CONFIGURATION

There are no configuration files or variables for this script.

=head1 EXIT STATUS

This script is intended to run as a simple daemon. As such, it will only exit
if it encounters an error, in which case it does so with an error status, or
is closed by an external process, in which case that process is responsible for
its own exit status.

=head1 INCOMPATIBILITIES

There are no known incompatibilities.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer (david at nebauer dot org)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2022 David Nebauer (david at nebauer dot org)

This script is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
# vim:foldmethod=marker:

#!/usr/bin/env bash
# This script unlocks the pass tomb, if any, and then usess fzf to find
# passwords and copy, show, delete, rename and duplicate them, as well as
# to add or generate new passwords, and synchronize them (with git).
# Dependencies: fd, fzf, mktemp, pass
# Optional dependencies: git, pass-tomb
#
# Based on Mathieu Laparie's passfzf available from
# https://git.sr.ht/~mlaparie/passfzf
#
# MIT License
#
# Copyright © [2022] Mathieu Laparie <mlaparie [at] disr [dot] it>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# configuration
fd='fdfind' # debian provides `fdfind` rather than `fd`
fzf='fzf'
pass='pass'
store="$HOME/.password-store/"
swapfile="/swap/swapfile" # set path to any swapfile not listed in /etc/fstab

# open pass tomb, if any
if [[ -e "$HOME/.password.tomb" ]]; then
  sudo swapoff -a && sudo swapoff "${swapfile}" 2>/dev/null
  "$pass" open 2>/dev/null
fi

# use temporary file
tmpfile="$(mktemp)"
trap '[[ -f "${tmpfile:-}" ]] && rm -rf "$tmpfile"' EXIT

# select pass entry and user action
selection=$(
  "$fd" .gpg ~/.password-store/ -d 8 |
    "$fzf" \
      --prompt="# " \
      --ansi \
      --extended \
      --no-border \
      --with-nth 5.. \
      --delimiter "/" \
      --layout=reverse-list \
      --no-multi \
      --cycle \
      --header='
| Ret: clip | C-t: trash    | M-<: git pull | C-a: add/insert   |
| C-s: show | C-r: rename   | M->: git push | C-c/C-q/Esc: exit |
| C-e: edit | C-o: copy OTP | C-d: copy     |
| C-g: generate and copy new password       |' \
      --margin='1,2,1,2' \
      --color='16,gutter:-1' \
      --bind="tab:down" \
      --bind="btab:up" \
      --bind="ctrl-a:execute(echo 'add' > $tmpfile)+accept-or-print-query" \
      --bind="ctrl-d:execute(echo 'cp' > $tmpfile)+accept" \
      --bind="ctrl-e:execute(echo 'edit' > $tmpfile)+accept" \
      --bind="ctrl-g:execute(echo 'generate --clip' > $tmpfile)+accept-or-print-query" \
      --bind="ctrl-o:execute(echo 'otp --clip' > $tmpfile)+accept" \
      --bind="ctrl-r:execute(echo 'mv' > $tmpfile)+accept" \
      --bind="ctrl-s:execute(echo 'show' > $tmpfile)+accept" \
      --bind="ctrl-t:execute(echo 'rm' > $tmpfile)+accept" \
      --bind="alt-<:execute(echo 'git pull' > $tmpfile)+abort" \
      --bind="alt->:execute(echo 'git push -u --all' > $tmpfile)+abort" \
      --bind="enter,alt-enter:execute(echo 'show --clip' > $tmpfile)+accept" \
      --bind="ctrl-c,ctrl-q,esc:execute(echo 'quit' > $tmpfile)+cancel"
)

# get user action
arg="$(cat "$tmpfile")"
rm "$tmpfile"
trap - EXIT

# process actions that do not use selected pass entry
action_taken=false
case "$arg" in
"git pull")
  echo -e "\033[0;32m\nPerforming git pull...\033[0m"
  "$pass" git pull
  action_taken=true
  ;;
"git push -u --all")
  echo -e "\033[0;32m\nPerforming git push...\033[0m"
  "$pass" git push --set-upstream --all
  action_taken=true
  ;;
quit)
  pkill -P $$
  action_taken=true
  ;;
esac

# process actions that use selected pass entry
if [[ $action_taken = false ]]; then
  if { ! [[ -v "selection" ]]; } || [[ -z "$selection" ]]; then
    echo -e "\033[0;31mError:\033[0m no name selected" 1>&2
  else
    # trim '.gpg' extension and path to store directory
    selection=${selection%.gpg} && selection=${selection#"$store"}
    case "$arg" in
    "add")
      "$pass" insert "${selection}" # 'add' is a synonym for 'insert'
      ;;
    "cp" | "mv")
      printf "\033[0;32m\nNew name to %s '%s' to:\033[0m\n" "${arg}" "${selection}"
      read -r -e
      if [[ -n "$REPLY" ]]; then
        "$pass" "${arg}" "${selection}" "${REPLY}"
      fi
      ;;
    "edit")
      "$pass" edit "${selection}"
      ;;
    "generate --clip")
      printf "\033[0;32mSelected name:\033[0m %s" "${selection}"
      printf "\033[0;32m\nName to generate password for (default=selection):\033[0m\n"
      read -r -e
      if [[ -n "$REPLY" ]]; then
        selection="$REPLY"
      fi
      printf "\033[0;32mNumber of characters (default=16):\033[0m "
      read -r
      num_chars=16
      if [[ -n "$REPLY" ]]; then
        num_chars="$REPLY"
      fi
      gen_args=('generate' '--clip')
      printf "\033[0;32mExclude symbols [y/n] (default=n):\033[0m "
      read -r -s -n 1
      echo "$REPLY"
      if [[ "${REPLY,,}" == 'y' ]]; then # ${var,,} converts to lowercase
        gen_args+=('--no-symbols')
      fi
      "$pass" "${gen_args[@]}" --in-place "${selection}" "${num_chars}" 2>/dev/null ||
        "$pass" "${gen_args[@]}" "${selection}" "${num_chars}"
      ;;
    "otp --clip")
      if ! "$pass" otp 2>&1 | grep -q "Usage: $pass otp"; then
        echo -e "\033[0;31mError:\033[0m the pass-otp extension not installed" 1>&2
      else
        "$pass" otp --clip "${selection}"
      fi
      ;;
    "rm")
      "$pass" rm "${selection}"
      ;;
    "show")
      "$pass" show "${selection}"
      ;;
    "show --clip")
      "$pass" show --clip "${selection}"
      ;;
    *)
      printf "\033[0;32mSelected name:\033[0m %s" "${selection}"
      echo -e "\033[0;31mError:\033[0m unknown action: '$arg'" 1>&2
      if [[ -n "$selection" ]]; then
        "$pass" "${arg}" "${selection}"
      else
        "$pass" "${arg}"
      fi
      ;;
    esac
  fi
fi

# close pass tomb, if any
if [[ -e "$HOME/.password.tomb" ]]; then
  printf "\n"
  "$pass" close
  sudo swapon -a && sudo swapon "${swapfile}" 2>/dev/null
fi
